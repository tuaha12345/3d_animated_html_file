<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naughty Boy Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div class="info">
        <h3>ðŸ˜ˆ Naughty Boy</h3>
        <p>Watch what he does...</p>
        <button onclick="restartAnimation()">Restart</button>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, boy, ground;
        let animationId;
        let time = 0;
        let phase = 'walking';
        let walkDistance = 0;
        let poop = null;
        let hasLooked = false;
        let poopTime = 0;
        let throwTime = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 2, 8);
            camera.lookAt(0, 1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x7CFC00,
                roughness: 0.8,
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            createBoy();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createBoy() {
            boy = new THREE.Group();

            // Body (cylinder)
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.35, 1, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            boy.add(body);

            // Head (sphere)
            const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBAC });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.75;
            head.castShadow = true;
            boy.head = head;
            boy.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.12, 1.82, 0.28);
            boy.leftEye = leftEye;
            boy.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.12, 1.82, 0.28);
            boy.rightEye = rightEye;
            boy.add(rightEye);

            // Mouth (mischievous smile)
            const mouthGeometry = new THREE.TorusGeometry(0.12, 0.03, 8, 16, Math.PI);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.55, 0.3);
            mouth.rotation.x = Math.PI;
            boy.mouth = mouth;
            boy.add(mouth);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBAC });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 1, 0);
            leftArm.rotation.z = 0.3;
            boy.leftArm = leftArm;
            boy.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 1, 0);
            rightArm.rotation.z = -0.3;
            boy.rightArm = rightArm;
            boy.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2F4F4F });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.4, 0);
            boy.leftLeg = leftLeg;
            boy.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.4, 0);
            boy.rightLeg = rightLeg;
            boy.add(rightLeg);

            boy.position.set(-8, 0, 0);
            scene.add(boy);
        }

        function createPoop() {
            // Create poop shape (organic blob)
            const poopGroup = new THREE.Group();
            
            const poopMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });

            // Bottom sphere (largest)
            const bottom = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 12, 12),
                poopMaterial
            );
            bottom.scale.set(1, 0.8, 1);
            bottom.position.y = 0;
            poopGroup.add(bottom);

            // Middle sphere
            const middle = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 12, 12),
                poopMaterial
            );
            middle.position.y = 0.15;
            poopGroup.add(middle);

            // Top sphere (smallest)
            const top = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 12, 12),
                poopMaterial
            );
            top.position.y = 0.28;
            poopGroup.add(top);

            // Swirl on top
            const swirlGeometry = new THREE.TorusGeometry(0.06, 0.02, 8, 12, Math.PI * 1.5);
            const swirl = new THREE.Mesh(swirlGeometry, poopMaterial);
            swirl.position.y = 0.35;
            swirl.rotation.x = Math.PI / 2;
            poopGroup.add(swirl);

            poopGroup.castShadow = true;
            poopGroup.position.set(boy.position.x, 0.2, boy.position.z - 0.5);
            
            poop = poopGroup;
            poop.velocity = { x: 0, y: 0, z: 0 };
            poop.rotationVel = { x: 0, y: 0, z: 0 };
            scene.add(poop);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            time += 0.016;

            if (phase === 'walking') {
                walkDistance += 0.03;
                boy.position.x += 0.03;

                // Walking animation
                boy.leftArm.rotation.x = Math.sin(time * 5) * 0.5;
                boy.rightArm.rotation.x = -Math.sin(time * 5) * 0.5;
                boy.leftLeg.rotation.x = -Math.sin(time * 5) * 0.4;
                boy.rightLeg.rotation.x = Math.sin(time * 5) * 0.4;
                boy.position.y = Math.abs(Math.sin(time * 5)) * 0.05;

                if (walkDistance > 5) {
                    phase = 'looking';
                }
            } else if (phase === 'looking' && !hasLooked) {
                // Turn to face camera
                boy.rotation.y += 0.05;
                
                if (boy.rotation.y >= Math.PI / 2) {
                    boy.rotation.y = Math.PI / 2;
                    hasLooked = true;
                    phase = 'squatting';
                }
            } else if (phase === 'squatting') {
                poopTime += 0.016;
                
                // Squat animation
                const squatAmount = Math.min(poopTime * 2, 0.3);
                boy.position.y = -squatAmount;
                boy.leftLeg.rotation.x = squatAmount * 2;
                boy.rightLeg.rotation.x = squatAmount * 2;

                if (poopTime > 0.5 && !poop) {
                    createPoop();
                }

                if (poopTime > 1.5) {
                    phase = 'standing';
                    poopTime = 0;
                }
            } else if (phase === 'standing') {
                poopTime += 0.016;
                
                // Stand back up
                const standAmount = Math.max(boy.position.y + 0.02, 0);
                boy.position.y = standAmount;
                boy.leftLeg.rotation.x = Math.max(boy.leftLeg.rotation.x - 0.03, 0);
                boy.rightLeg.rotation.x = Math.max(boy.rightLeg.rotation.x - 0.03, 0);

                if (boy.position.y >= 0) {
                    phase = 'picking';
                }
            } else if (phase === 'picking') {
                poopTime += 0.016;
                
                // Bend down to pick up poop
                boy.rotation.x = Math.min(poopTime * 2, 0.8);
                boy.rightArm.rotation.x = -Math.min(poopTime * 3, 1.5);

                if (poopTime > 0.8 && poop) {
                    // Attach poop to hand
                    const handPos = new THREE.Vector3();
                    boy.rightArm.getWorldPosition(handPos);
                    poop.position.set(
                        boy.position.x + 0.4,
                        boy.position.y + 0.3,
                        boy.position.z + 0.3
                    );
                    phase = 'throwing';
                    poopTime = 0;
                }
            } else if (phase === 'throwing') {
                throwTime += 0.016;
                
                // Wind up throw
                if (throwTime < 0.5) {
                    boy.rotation.x = Math.max(0.8 - throwTime * 1.6, 0);
                    boy.rightArm.rotation.x = -1.5 + throwTime * 2;
                    
                    if (poop) {
                        poop.position.set(
                            boy.position.x + 0.4,
                            boy.position.y + 0.5 + throwTime,
                            boy.position.z + 0.3
                        );
                    }
                } else if (throwTime === 0.5 || (throwTime > 0.5 && poop && poop.velocity.z === 0)) {
                    // Release poop
                    if (poop) {
                        poop.velocity = { x: 0, y: 0.15, z: 0.25 };
                        poop.rotationVel = { x: 0.1, y: 0.15, z: 0.08 };
                    }
                }
                
                // Animate thrown poop
                if (poop && poop.velocity.z > 0) {
                    poop.position.x += poop.velocity.x;
                    poop.position.y += poop.velocity.y;
                    poop.position.z += poop.velocity.z;
                    
                    // Rotation
                    poop.rotation.x += poop.rotationVel.x;
                    poop.rotation.y += poop.rotationVel.y;
                    poop.rotation.z += poop.rotationVel.z;
                    
                    // Gravity
                    poop.velocity.y -= 0.008;
                    
                    // Grow as it approaches
                    const distanceFactor = (poop.position.z - boy.position.z) / 7;
                    const scale = 1 + distanceFactor * 3;
                    poop.scale.set(scale, scale, scale);
                    
                    // Hit the screen
                    if (poop.position.z >= 7.5) {
                        phase = 'impact';
                        createImpact();
                    }
                }
            } else if (phase === 'impact') {
                // Wait a bit then restart
                throwTime += 0.016;
                if (throwTime > 2) {
                    restartAnimation();
                }
            }

            renderer.render(scene, camera);
        }

        function createImpact() {
            // Create splatter particles
            const particleCount = 30;
            
            for (let i = 0; i < particleCount; i++) {
                const size = 0.05 + Math.random() * 0.1;
                const particleGeometry = new THREE.SphereGeometry(size, 8, 8);
                const particleMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    poop.position.x + (Math.random() - 0.5) * 2,
                    poop.position.y + (Math.random() - 0.5) * 2,
                    7
                );
                
                scene.add(particle);
                
                // Animate particles spreading
                const spreadAnim = setInterval(() => {
                    particle.position.x += (Math.random() - 0.5) * 0.1;
                    particle.position.y += (Math.random() - 0.5) * 0.1;
                }, 30);
                
                setTimeout(() => {
                    clearInterval(spreadAnim);
                    scene.remove(particle);
                }, 1500);
            }
            
            if (poop) {
                scene.remove(poop);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function restartAnimation() {
            // Clean up
            if (poop) {
                scene.remove(poop);
                poop = null;
            }

            // Reset variables
            time = 0;
            phase = 'walking';
            walkDistance = 0;
            hasLooked = false;
            poopTime = 0;
            throwTime = 0;

            // Reset boy
            boy.position.set(-8, 0, 0);
            boy.rotation.set(0, 0, 0);
            boy.leftArm.rotation.x = 0;
            boy.rightArm.rotation.x = 0;
            boy.leftLeg.rotation.x = 0;
            boy.rightLeg.rotation.x = 0;
        }

        init();
    </script>
</body>
</html>